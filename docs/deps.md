# Зависимости

## Назначение

Для сборки и запуска целевой программы (**sdcam**) требуется ряд сторонних библиотек. Такие библиотеки называются зависимостями. Платформа **sdcam** реализована с использованием двух основных языков программирования (ЯП):

* Python;
* C++.

На **Python** описана т.н. бизнес-логика&nbsp;– высокоуровневая алгоритмика программы, а также её интерфейс пользователя. На **C++**, в свою очередь, реализуются низкоуровневые операции, являющиеся затратными в вычислительном плане. Каждый из ЯП имеет свои зависимости, перечень которых и способы установки приведены ниже.

Очевидно, что рабочая станция разработчика для работы с платформой **sdcam** должна быть подготовлена, и эта подготовка сводится к установке зависимостей и [инструментов](../tools), а также настройке всего этого.

## Python

В случае **Python** всё достаточно просто, т.к. все зависимости доступны из PyPi репозиториев и устанавливаются утилитой `pip`. 

Используемые зависимости:

|  Name        | Installation                |
|--------------|-----------------------------|
| pyqt5        | `pip install pyqt5`         |
| jupyter      | `pip install jupyter`       |
| numpy        | `pip install numpy`         |
| matplotlib   | `pip install matplotlib`    |


## C++

### Размещение зависимостей

Существует несколько подходов к размещению зависимостей. 

#### Добавление копии библиотеки в проект

Самый простой способ&nbsp;– просто скопировать исходные файлы сторонних библиотек в директорию с проектом. Этот вариант имеет несколько существенных недостатков:

* операцию приходится выполнять вручную для каждого проекта;
* библиотеки "поселяются" в проекте, занимают место, зачастую намного больше, чем исходные файлы
  самого проекта;
* обновление и отслеживание изменений также необходимо выполнять вручную.

Принимая во внимание всё это, данный способ нельзя признать удовлетворительным.

#### Добавление с помощью системы управления версиями

Второй способ похож на предыдущий, но размещение сторонних библиотек в проекте осуществляется средствами системы контроля версий&nbsp;– например, в случае использования **git**&nbsp;– это подмодули. В этом варианте с контролем версий и развёртыванием всё в порядке.

Недостатком по-прежнему остаётся избыточное место в дереве исходных файлов. При использовании библиотеки в нескольких проектах это приводит к дублированию. И при резервном копировании этот избыточный объём создаёт дополнительную нагрузку.

Несомненным плюсом данного метода является привязка проекта к конкретной версии библиотеки&nbsp;– эту привязку контролирует система контроля версий.


#### Размещение в отдельном месте

Третий способ&nbsp;– это размещать библиоетку в отдельном специально созданном для этого месте. Здесь нет дублирования файлов, нет трудностей с развёртыванием&nbsp;– это делается обычным способом средствами системы управления версиями. 

К недостаткам можно отнести следующие:

  * нет автоматической привязки проекта к конкретной версии библиотеки. Это чревато поломкой сборки
    при обновлении библиотеки. В этом случае необходимо следить за целостностью библиотеки, и если
    для какого-то проекта нужна более свежая версия, то, например, разворачивать её рядом под
    другим именем и делать в проекте ссылку на неё;
  * необходимо вручную выполнять начальное развёртывание. Собственно, этому и посвящена текущая
    страница.

Для проекта **sdcam** выбран третий способ. Все зависимости размещаются в одной директории, путь к которой задаётся переменной окружения. Например:

```shell
export EXTERNAL_LIB=/opt/lib
```

### Установка зависимостей

Проект **sdcam** требует следующие библиотеки:

  * **Boost.Python**. Библиотека **Boost.Python** используется для создания расширений на ЯП **C++**
      для ЯП **Python**. Библиотека входит в состав коллекции **С++** библиотек **Boost**;
  * **fmtlib**. Библиотека для форматированной печати;
  * **spdlog**. Библиотека для организации логирования.

Для сборки **fmtlib** и **spdlog** требуется утилита **cmake**. На дистрибутивах **Debian/Ubuntu** может быть установлена командой:

```shell
sudo apt install cmake
```

#### Boost.Python

1. Скачать tarball архив с официального сайта: http://www.boost.org/users/download/.
2. Распаковать архив во временную директорию.
3. Выполнить следующие команды, указав префикс целевого пути установки.

```shell
./bootstrap.sh --prefix=$EXTERNAL_LIB/boost/<vernum> --with-python=/usr/bin/python3 
./b2
./b2 install
```

где `<vernum>`&nbsp;– номер версии библиотеки, например: `1_84_0`

В завершение необходимо добавить путь к библиотеке в кэш поиска динамических библиотек:

```shell
sudo sh -c "echo $EXTERNAL_LIB/boost/<vernum>/lib > /etc/ld.so.conf.d/boost.conf"
sudo ldconfig
```

#### fmtlib

Выполнить следующие команды:

```shell
cd $EXTERNAL_LIB
mkdir -p fmt/source
cd fmt/source
git clone --recursive https://github.com/cam-lab/fmt.git .
git checkout dev
./build-fmtlib.sh
```

#### spdlog

Выполнить следующие команды:

```shell
cd $EXTERNAL_LIB
mkdir -p spdlog/source
cd spdlog/source
git clone --recursive https://github.com/cam-lab/spdlog.git .
./build-spdlog.sh
```

## Настройка хоста

Для работы программы помимо установленных библиотек также требуется наличие сетевого сокета, через который осуществляется обмен данными с прибором. Для этих целей целесообразно иметь выделенный сетевой интерфейс с поддержкой скоростей передачи от 1Gbps и выше. Такой интерфейс удобно настроить со статическим сетевым адресом, дабы избежать сложностей и накладных расходов на поддержку DHCP в целевом приборе.

Создание интерфейса на дистрибутивах **Ubuntu** можно выполнить с помощью команды:

```shell
nmcli con add type ethernet con-name 'camif' ifname enp11s0 ipv4.method manual ipv4.addresses 192.168.10.1/24 ipv4.gateway 192.168.10.255
```

Запуск интерфейса:

```shell
nmcli con up id 'camif'

```
